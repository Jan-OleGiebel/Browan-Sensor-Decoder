// *** Browan Communications Inc. ***
//
// *** JavaScript decoder  only for TTN network server***
// 
// Support parser Sensor type: 
// 【Door & Window Sensor】,【Motion Sensor】 ,【 Temperature & Humidity Sensor】
// 【Healthy Home Sensor(IAQ) 】,【Ambient Light Sensor 】,【Sound Level Sensor】
// 【Water Leak Sensor 】,【Object Locator Sensor 】,【Industrial Tracker Sensor】
// 【Temperature Probe Sensor】
//
// Version v4.0
//

//#################### * Door & Window  *#################### //

//hex to binary function
function hex2bin(hex){
  return (parseInt(hex, 16).toString(2)).padStart(8, '0');
}
// hex covert
function paddingLeft(str,lenght){
	if(str.length >= lenght)
	return str;
	else
	return paddingLeft("0" +str,lenght);
}
// little-endian format
function littleendian(inputpayload) {
  var data = inputpayload.match(/../g);
  var buf = new ArrayBuffer(4);
  // Create a data view of it
  var view = new DataView(buf);
  // set bytes
  data.forEach(function (b, i) {
  view.setUint8(i, parseInt(b, 16));
  });
  // get an int32 with little endian
  var num = view.getInt32(0, 1);

  return num;
}
// little-endian format(hex to string)
function littleendianhex(inputpayload) {
  var inputlengh = inputpayload.length;
  var outputstr ='';
  for(let y=inputlengh;y>=1;y-=2){
    outputstr = outputstr+inputpayload[y-2]+inputpayload[y-1];
  }
  return outputstr;
}
// tabs sensor-Door & Window 
function decodeUplink(input) {
  var fPort = input.fPort;
  var payloadlens = input.bytes.length;
  if(fPort==222 && payloadlens==17){//Frame Count 0 Content
    var intput_list = input.bytes;
    var intput_liststr='';
    for(let i=0;i<17;i++){
      intput_liststr = intput_liststr+paddingLeft(intput_list[i].toString(16),2);
    }
    var bootloader_hex = intput_liststr.toString("hex").substring(2, 10);
    var hwid_hex = intput_liststr.toString("hex").substring(10, 18);
    var fwcrc_hex = intput_liststr.toString("hex").substring(18, 26);
    bootloader = littleendianhex(bootloader_hex);
    HW_ID = littleendianhex(hwid_hex);
    FW_CRC = littleendianhex(fwcrc_hex);

    return {
      data: {
      fPort,
      bootloader,
      HW_ID,
      FW_CRC,
      },
    };
  }
  else if(fPort==204 && payloadlens==5){ //Response Content (Only for unconfirmed downlink)
    var intput_list = input.bytes;
    var intput_liststr='';
    for(let i=0;i<payloadlens;i++){
      intput_liststr = intput_liststr+paddingLeft(intput_list[i].toString(16),2);
    }

    var door_keepalivehex = intput_liststr.toString("hex").substring(2, 6);
    var door_keepalive = littleendian(door_keepalivehex); // (sec), Keep alive interval (reporting interval)
    
    return {
      data: {
        fPort,
        payloadlens,
        door_keepalive,
      },
    };
  }
  else if(fPort==100 && payloadlens==8){
    var intput_list = input.bytes;
    var intput_liststr='';
    var battery_hex=intput_list[1].toString(16);
    var battery_binary = hex2bin(battery_hex); 
    var battery_binary2 = battery_binary.substring(4, 8);
    var battery_int = parseInt(battery_binary2,2)
    battery_volt = (25+battery_int)/10;             // battery voltage
	
	var temppcb_hex=intput_list[2].toString(16);
	var temppcb_binary = hex2bin(temppcb_hex); 
	var temppcb_binary2 = temppcb_binary.substring(1, 8);
	var temppcb_int = parseInt(temppcb_binary2,2)
	temperature = temppcb_int-32; // Temperature on board NTC

    for(let i=0;i<payloadlens;i++){
      intput_liststr = intput_liststr+paddingLeft(intput_list[i].toString(16),2);
    }
    var door_timehex = intput_liststr.toString("hex").substring(6, 10);
    var door_counthex = intput_liststr.toString("hex").substring(10, 16);
    var door_hex = intput_list[0].toString(16);
    var door_binary = hex2bin(door_hex); 
    var open_st = door_binary.substring(7, 8);
    door_doorst = parseInt(open_st);                  //Door Status 1 – open, 0 – closed
    door_time = littleendian(door_timehex);           // Time elapsed since the last event-triggered
    door_count = littleendian(door_counthex);         // Total count of event-triggered

    return {
      data: {
      fPort,
      battery_volt,
      temperature,
      door_doorst,
      door_time,
      door_count,
      },
    };
  }
  else{
    var fPort = input.fPort;
    var payloadlength = input.bytes.length;
    var message = 'Invalid fPort or payload length';
    return {
      data: {
        fPort,
        payloadlength,
        message,
      },
    };
  }
}

//#################### * Door & Window  End !! *#################### //

//#################### * Motion Sensor  *#################### //

//hex to binary function
function hex2bin(hex){
  return (parseInt(hex, 16).toString(2)).padStart(8, '0');
}
// hex covert
function paddingLeft(str,lenght){
	if(str.length >= lenght)
	return str;
	else
	return paddingLeft("0" +str,lenght);
}
// little-endian format
function littleendian(inputpayload) {
  var data = inputpayload.match(/../g);
  var buf = new ArrayBuffer(4);
  // Create a data view of it
  var view = new DataView(buf);
  // set bytes
  data.forEach(function (b, i) {
  view.setUint8(i, parseInt(b, 16));
  });
  // get an int32 with little endian
  var num = view.getInt32(0, 1);

  return num;
}
// little-endian format(hex to string)
function littleendianhex(inputpayload) {
  var inputlengh = inputpayload.length;
  var outputstr ='';
  for(let y=inputlengh;y>=1;y-=2){
    outputstr = outputstr+inputpayload[y-2]+inputpayload[y-1];
  }
  return outputstr;
}
// tabs sensor- Motion sensor 
function decodeUplink(input) {
  var fPort = input.fPort;
  var payloadlens = input.bytes.length;
  if(fPort==222 && payloadlens==17){//Frame Count 0 Content
    var intput_list = input.bytes;
    var intput_liststr='';
    for(let i=0;i<17;i++){
      intput_liststr = intput_liststr+paddingLeft(intput_list[i].toString(16),2);
    }
    var bootloader_hex = intput_liststr.toString("hex").substring(2, 10);
    var hwid_hex = intput_liststr.toString("hex").substring(10, 18);
    var fwcrc_hex = intput_liststr.toString("hex").substring(18, 26);
    bootloader = littleendianhex(bootloader_hex);
    HW_ID = littleendianhex(hwid_hex);
    FW_CRC = littleendianhex(fwcrc_hex);

    return {
      data: {
      fPort,
      bootloader,
      HW_ID,
      FW_CRC,
      },
    };
  }
  else if(fPort==204 && payloadlens==16){ //Response Content (Only for unconfirmed downlink)
    var intput_list = input.bytes;
    var intput_liststr='';
    for(let i=0;i<payloadlens;i++){
      intput_liststr = intput_liststr+paddingLeft(intput_list[i].toString(16),2);
    }

    var mot_keepalivehex = intput_liststr.toString("hex").substring(2, 6);
    var mot_occupiedhex = intput_liststr.toString("hex").substring(8, 12);
    var mot_freehex = intput_list[7].toString(16);
    var mot_trigcthex = intput_liststr.toString("hex").substring(18, 22);
    var mot_parmthex = intput_liststr.toString("hex").substring(24, 32);

    var mot_keepalive = littleendian(mot_keepalivehex); // (sec), Keep alive interval (reporting interval)
    var mot_occupied = littleendian(mot_occupiedhex); // (sec) ,  Occupied interval
    var mot_free = parseInt(mot_freehex,16); // (min) , Free detection time
    var mot_trigct = littleendian(mot_trigcthex); // Trigger Count in the occupied status
    var mot_parmter = littleendianhex(mot_parmthex); // PIR parameter
    
    return {
      data: {
        fPort,
        payloadlens,
        mot_keepalive,
        mot_occupied,
        mot_free,
        mot_trigct,
        mot_parmter,
      },
    };
  }
  else if(fPort==102 && payloadlens==8){
    var intput_list = input.bytes;
    var intput_liststr='';
    var battery_hex=intput_list[1].toString(16);
    var battery_binary = hex2bin(battery_hex); 
    var battery_binary2 = battery_binary.substring(4, 8);
    var battery_int = parseInt(battery_binary2,2)
    battery_volt = (25+battery_int)/10;        // battery voltage
	
	var temppcb_hex=intput_list[2].toString(16);
	var temppcb_binary = hex2bin(temppcb_hex); 
	var temppcb_binary2 = temppcb_binary.substring(1, 8);
	var temppcb_int = parseInt(temppcb_binary2,2)
	temperature = temppcb_int-32; // Temperature on board NTC

    for(let i=0;i<payloadlens;i++){
      intput_liststr = intput_liststr+paddingLeft(intput_list[i].toString(16),2);
    }

    var motion_hex = intput_list[0].toString(16);
    var motion_binary = hex2bin(motion_hex); 
    var motion_st = motion_binary.substring(7, 8);
    var mot_timehex = intput_liststr.toString("hex").substring(6, 10);
    var mot_counthex = intput_liststr.toString("hex").substring(10, 16);
    mot_motionst = parseInt(motion_st);             // motion Status; 1 – occupied, 0 – free
    mot_times = littleendian(mot_timehex);           // Time elapsed since the last event-triggered
    mot_counts = littleendian(mot_counthex);         // Total count of event-triggered

    return {
      data: {
      fPort,
      battery_volt,
      temperature,
      mot_motionst,
      mot_times,
      mot_counts,
      },
    };
  }
  else{
    var fPort = input.fPort;
    var payloadlength = input.bytes.length;
    var message = 'Invalid fPort or payload length';
    return {
      data: {
        fPort,
        payloadlength,
        message,
      },
    };
  }
}
//#################### * Motion Sensor  End !!  *#################### //

//#################### * Temperature & Humidity Sensor *#################### //

//hex to binary function
function hex2bin(hex){
  return (parseInt(hex, 16).toString(2)).padStart(8, '0');
}
// hex covert
function paddingLeft(str,lenght){
	if(str.length >= lenght)
	return str;
	else
	return paddingLeft("0" +str,lenght);
}
// little-endian format
function littleendian(inputpayload) {
  var data = inputpayload.match(/../g);
  var buf = new ArrayBuffer(4);
  // Create a data view of it
  var view = new DataView(buf);
  // set bytes
  data.forEach(function (b, i) {
  view.setUint8(i, parseInt(b, 16));
  });
  // get an int32 with little endian
  var num = view.getInt32(0, 1);

  return num;
}
// little-endian format(hex to string)
function littleendianhex(inputpayload) {
  var inputlengh = inputpayload.length;
  var outputstr ='';
  for(let y=inputlengh;y>=1;y-=2){
    outputstr = outputstr+inputpayload[y-2]+inputpayload[y-1];
  }
  return outputstr;
}
// tabs sensor- Temperature & Humidity Sensor
function decodeUplink(input) {
  var fPort = input.fPort;
  var payloadlens = input.bytes.length;
  
  if(fPort==222 && payloadlens==17){//Frame Count 0 Content
    var intput_list = input.bytes;
    var intput_liststr='';
    for(let i=0;i<17;i++){
      intput_liststr = intput_liststr+paddingLeft(intput_list[i].toString(16),2);
    }
    var bootloader_hex = intput_liststr.toString("hex").substring(2, 10);
    var hwid_hex = intput_liststr.toString("hex").substring(10, 18);
    var fwcrc_hex = intput_liststr.toString("hex").substring(18, 26);
    bootloader = littleendianhex(bootloader_hex);
    HW_ID = littleendianhex(hwid_hex);
    FW_CRC = littleendianhex(fwcrc_hex);

    return {
      data: {
      fPort,
      bootloader,
      HW_ID,
      FW_CRC,
      },
    };
  }
  else if(fPort==204 && payloadlens==12){ //Response Content (Only for unconfirmed downlink)
    var intput_list = input.bytes;
    var intput_liststr='';
    for(let i=0;i<payloadlens;i++){
      intput_liststr = intput_liststr+paddingLeft(intput_list[i].toString(16),2);
    }

    var thh_keepalive_hex = intput_liststr.toString("hex").substring(2, 6);
    var thh_Monitorhex = intput_liststr.toString("hex").substring(8, 12);
    var thh_temptrighex = intput_list[7].toString(16);
    var thh_rhtrighex = intput_list[9].toString(16);

    var thh_keepalive = littleendian(thh_keepalive_hex); // (sec), Keep alive interval
    var thh_Monitor = littleendian(thh_Monitorhex); // (sec) , Monitor time interval
    var thh_temptrig = parseInt(thh_temptrighex,16); // (oC) , Temperature trigger value
    var thh_rhtrig = parseInt(thh_rhtrighex,16); // (%RH) , Humidity trigger value

    return {
      data: {
        fPort,
        payloadlens,
        thh_keepalive,
        thh_Monitor,
        thh_temptrig,
        thh_rhtrig,
      },
    };
  }
  else if(fPort==103 && payloadlens==8){
    var intput_list = input.bytes;
    var battery_hex=intput_list[1].toString(16);
    var battery_binary = hex2bin(battery_hex); 
    var battery_binary2 = battery_binary.substring(4, 8);
    var battery_int = parseInt(battery_binary2,2)
    battery_volt = (25+battery_int)/10; // battery voltage
    
    var temp_hex=intput_list[2].toString(16);
    var temp_binary = hex2bin(temp_hex); 
    var temp_binary2 = temp_binary.substring(1, 8);
    var temp_int = parseInt(temp_binary2,2)
    temperature = temp_int-32; // Temperature on environment
    
    var humi_hex=intput_list[3].toString(16);
    var humi_binary = hex2bin(humi_hex); 
    var humi_binary2 = humi_binary.substring(1, 8);
    var humi_int = parseInt(humi_binary2,2)
    humidity = humi_int; // humidity on environment
    
    var thh_hex = intput_list[0].toString(16);
    var thh_binary = hex2bin(thh_hex); 
    var thh_typebin = thh_binary.substring(4, 5);
    var thh_type = parseInt(thh_typebin); // 1 – Temperature and humidity sensor type , 0 – IAQ Sensor type 
   
   	var CO2_hex = intput_list[5].toString(16)+intput_list[4].toString(16);
	var CO2 =0; //  THH sensor , no hardware always = FF. here set =0.
	
	var VOC_hex = intput_list[7].toString(16)+intput_list[6].toString(16);
	var VOC = 0 ; //  THH sensor , no hardware always = FF. here set =0.
	
    return {
      data: {
        fPort,
        battery_volt,
        temperature,
        humidity,
        thh_type,
		CO2,
		VOC,
      },
    };
  }
  else{
    var fPort = input.fPort;
    var payloadlength = input.bytes.length;
    var message = 'Invalid fPort or payload length';
    return {
      data: {
        fPort,
        payloadlength,
        message,
      },
    };
  }
}

//#################### * Temperature & Humidity End !! *#################### //

//#################### * Healthy Home Sensor(IAQ)  *#################### //

//hex to binary function
function hex2bin(hex){
  return (parseInt(hex, 16).toString(2)).padStart(8, '0');
}
// hex covert
function paddingLeft(str,lenght){
	if(str.length >= lenght)
	return str;
	else
	return paddingLeft("0" +str,lenght);
}
// little-endian format
function littleendian(inputpayload) {
  var data = inputpayload.match(/../g);
  var buf = new ArrayBuffer(4);
  // Create a data view of it
  var view = new DataView(buf);
  // set bytes
  data.forEach(function (b, i) {
  view.setUint8(i, parseInt(b, 16));
  });
  // get an int32 with little endian
  var num = view.getInt32(0, 1);

  return num;
}
// little-endian format(hex to string)
function littleendianhex(inputpayload) {
  var inputlengh = inputpayload.length;
  var outputstr ='';
  for(let y=inputlengh;y>=1;y-=2){
    outputstr = outputstr+inputpayload[y-2]+inputpayload[y-1];
  }
  return outputstr;
}

// tabs sensor- Temperature & Humidity Sensor
function decodeUplink(input) {
  var fPort = input.fPort;
  var payloadlens = input.bytes.length;

  if(fPort==222 && payloadlens==17){//Frame Count 0 Content
    var intput_list = input.bytes;
    var intput_liststr='';
    for(let i=0;i<17;i++){
      intput_liststr = intput_liststr+paddingLeft(intput_list[i].toString(16),2);
    }
    var bootloader_hex = intput_liststr.toString("hex").substring(2, 10);
    var hwid_hex = intput_liststr.toString("hex").substring(10, 18);
    var fwcrc_hex = intput_liststr.toString("hex").substring(18, 26);
    bootloader = littleendianhex(bootloader_hex);
    HW_ID = littleendianhex(hwid_hex);
    FW_CRC = littleendianhex(fwcrc_hex);

    return {
      data: {
      fPort,
      bootloader,
      HW_ID,
      FW_CRC,
      },
    };
  }
  else if(fPort==204 && payloadlens==8){ //Response Content (Only for unconfirmed downlink)
    var intput_list = input.bytes;
    var intput_liststr='';
    for(let i=0;i<payloadlens;i++){
      intput_liststr = intput_liststr+paddingLeft(intput_list[i].toString(16),2);
    }

    var iaq_keepalive_hex = intput_liststr.toString("hex").substring(2, 6);
    var iaq_tempdeltahex = intput_list[3].toString(16);
    var iaq_rhdeltahex = intput_list[5].toString(16);
    var iaq_indexdeltahex = intput_list[7].toString(16);

    var iaq_keepalive = (littleendian(iaq_keepalive_hex))*5; // (min), Keep alive interval ,always 5 multiples
    var iaq_tempdelta = parseInt(iaq_tempdeltahex,16); // (oC) , Temperature delta
    var iaq_rhdelta = parseInt(iaq_rhdeltahex,16); // (%RH) , RH delta
    var iaq_indexdelta = parseInt(iaq_indexdeltahex,16); // IAQ index delta

    return {
      data: {
        fPort,
        payloadlens,
        iaq_keepalive,
        iaq_tempdelta,
        iaq_rhdelta,
        iaq_indexdelta,
      },
    };
  }
  else if(fPort==103 && payloadlens==11){
    var intput_list = input.bytes;
    var battery_hex=intput_list[1].toString(16);
    var battery_binary = hex2bin(battery_hex); 
    var battery_binary2 = battery_binary.substring(4, 8);
    var battery_int = parseInt(battery_binary2,2)
    battery_volt = (25+battery_int)/10; // battery voltage
    
    var temppcb_hex=intput_list[2].toString(16);
    var temppcb_binary = hex2bin(temppcb_hex); 
    var temppcb_binary2 = temppcb_binary.substring(1, 8);
    var temppcb_int = parseInt(temppcb_binary2,2)
    temperature_pcb = temppcb_int-32; // Temperature on board NTC
    
    var humi_hex=intput_list[3].toString(16);
    var humi_binary = hex2bin(humi_hex); 
    var humi_binary2 = humi_binary.substring(1, 8);
    var humi_int = parseInt(humi_binary2,2)
    humidity = humi_int; // humidity on environment
    
    var iaq_hex = intput_list[0].toString(16);
    var iaq_binary = hex2bin(iaq_hex); 
    var iaq_typebin = iaq_binary.substring(4, 5);
    var iaq_statbin = iaq_binary.substring(7, 8);
    var temp_trigbin = iaq_binary.substring(3, 4);
    var rh_trigbin = iaq_binary.substring(2, 3);
    var iaq_trigbin = iaq_binary.substring(1, 2);

    iaq_type = parseInt(iaq_typebin); // 1 – Temperature and humidity sensor type , 0 – IAQ Sensor type 
    iaq_stat = parseInt(iaq_statbin); // 1 – Trigger Event, 0 – Keep-Alive 
    temp_trig = parseInt(temp_trigbin); // 1 - Temperature status is changed ( 2℃ delta)
    rh_trig = parseInt(rh_trigbin); // 1 - RH status is changed  (5% RH deltas)
    iaq_trig = parseInt(iaq_trigbin); // 1 - IAQ status is changed (25 IAQ index)
	
	var co2_hex = intput_list[5].toString(16)+intput_list[4].toString(16);
	var CO2 = parseInt(co2_hex,16);  // (ppm)
	
	var voc_hex = intput_list[7].toString(16)+intput_list[6].toString(16);
	var VOC = parseInt(voc_hex,16);
    
	var IAQ_hex = intput_list[9].toString(16)+intput_list[8].toString(16);
	var IAQ = parseInt(IAQ_hex,16); // ( value range 0~500)
	
    var tempenv_hex=intput_list[10].toString(16);
    var tempenv_binary = hex2bin(tempenv_hex); 
    var tempenv_binary2 = tempenv_binary.substring(1, 8);
    var tempenv_int = parseInt(tempenv_binary2,2)
    var temperature_env = tempenv_int-32; // Temperature on environment
	
    return {
      data: {
        fPort,
        battery_volt,
        temperature_pcb,
        humidity,
        iaq_type,
        iaq_stat,
        temp_trig,
        rh_trig,
        iaq_trig,
		CO2,
		VOC,
		IAQ,
		temperature_env,
      },
    };
  }
  else{
    var fPort = input.fPort;
    var payloadlength = input.bytes.length;
    var message = 'Invalid fPort or payload length';
    return {
      data: {
        fPort,
        payloadlength,
        message,
      },
    };
  }
}
//#################### * Healthy Home Sensor(IAQ) End !! *#################### //
//#################### * Ambient Light Sensor  *#################### //

//hex to binary function
function hex2bin(hex){
  return (parseInt(hex, 16).toString(2)).padStart(8, '0');
}
// hex covert
function paddingLeft(str,lenght){
	if(str.length >= lenght)
	return str;
	else
	return paddingLeft("0" +str,lenght);
}
// little-endian format
function littleendian(inputpayload) {
  var data = inputpayload.match(/../g);
  var buf = new ArrayBuffer(4);
  // Create a data view of it
  var view = new DataView(buf);
  // set bytes
  data.forEach(function (b, i) {
  view.setUint8(i, parseInt(b, 16));
  });
  // get an int32 with little endian
  var num = view.getInt32(0, 1);

  return num;
}
// little-endian format(hex to string)
function littleendianhex(inputpayload) {
  var inputlengh = inputpayload.length;
  var outputstr ='';
  for(let y=inputlengh;y>=1;y-=2){
    outputstr = outputstr+inputpayload[y-2]+inputpayload[y-1];
  }
  return outputstr;
}
// tabs sensor- Ambient Light Sensor
function decodeUplink(input) {
  var fPort = input.fPort;
  var payloadlens = input.bytes.length;
  if(fPort==222 && payloadlens==17){//Frame Count 0 Content
    var intput_list = input.bytes;
    var intput_liststr='';
    for(let i=0;i<17;i++){
      intput_liststr = intput_liststr+paddingLeft(intput_list[i].toString(16),2);
    }
    var bootloader_hex = intput_liststr.toString("hex").substring(2, 10);
    var hwid_hex = intput_liststr.toString("hex").substring(10, 18);
    var fwcrc_hex = intput_liststr.toString("hex").substring(18, 26);
    bootloader = littleendianhex(bootloader_hex);
    HW_ID = littleendianhex(hwid_hex);
    FW_CRC = littleendianhex(fwcrc_hex);

    return {
      data: {
      fPort,
      bootloader,
      HW_ID,
      FW_CRC,
      },
    };
  }
  else if(fPort==204 && payloadlens==9){ //Response Content (Only for unconfirmed downlink)
    var intput_list = input.bytes;
    var intput_liststr='';
    for(let i=0;i<payloadlens;i++){
      intput_liststr = intput_liststr+paddingLeft(intput_list[i].toString(16),2);
    }

    var light_keepalive_hex = intput_liststr.toString("hex").substring(2, 6);
    var light_detect_hex = intput_liststr.toString("hex").substring(8, 12);
    var light_trigdel_hex = intput_liststr.toString("hex").substring(14, 18);

    var light_keepalive = littleendian(light_keepalive_hex); // (sec), Keep alive interval
    var light_detect = littleendian(light_detect_hex); // (sec) , Monitor interval
    var light_trigdel = littleendian(light_trigdel_hex); // (lux) , Trigger delta lux value

    return {
      data: {
        fPort,
        payloadlens,
        light_keepalive,
        light_detect,
        light_trigdel,
      },
    };
  }
  else if(fPort==104 && payloadlens==4){
    var intput_list = input.bytes;
    var battery_hex=intput_list[1].toString(16);
    var battery_binary = hex2bin(battery_hex); 
    var battery_binary2 = battery_binary.substring(4, 8);
    var battery_int = parseInt(battery_binary2,2)
    battery_volt = (25+battery_int)/10; // battery voltage
    
    var temp_hex=intput_list[2].toString(16);
    var temp_binary = hex2bin(temp_hex); 
    var temp_binary2 = temp_binary.substring(1, 8);
    var temp_int = parseInt(temp_binary2,2)
    temperature = temp_int-32; // Temperature on environment
        
    var light_hex = intput_list[0].toString(16);
    var light_binary = hex2bin(light_hex);
    var dark_chagbin = light_binary.substring(7,8); //[0]
    var light_chagbin = light_binary.substring(6,7); //[1]
    var light_statbin = light_binary.substring(3,4); //[4]
    var light_keepbin = light_binary.substring(2,3); //[5]

    dark_chag = parseInt(dark_chagbin); // 1 - darker, 0 - lighter or not change
    light_chag = parseInt(light_chagbin); // 1 - lighter, 0 - darker or not change
    light_stat = parseInt(light_statbin); // 1 - status change, 0 - not status change
    light_keep = parseInt(light_keepbin); // 1 - keep-alive, 0 - not keep-alive

    var lightlux_hex = intput_list[5].toString(16)+intput_list[4].toString(16)+intput_list[3].toString(16);
    light_lux = parseInt(lightlux_hex, 16); //Lux data
    
    return {
      data: {
        fPort,
        battery_volt,
        temperature,
        dark_chag,
        light_chag,
        light_stat,
        light_keep,
        light_lux
      },
    };
  }
  else{
    var fPort = input.fPort;
    var payloadlength = input.bytes.length;
    var message = 'Invalid fPort or payload length';
    return {
      data: {
        fPort,
        payloadlength,
        message,
      },
    };
  }

}

//#################### * Ambient Light Sensor End !! *#################### //
//#################### * Sound Level Sensor  *#################### //

//hex to binary function
function hex2bin(hex){
  return (parseInt(hex, 16).toString(2)).padStart(8, '0');
}
// hex covert
function paddingLeft(str,lenght){
	if(str.length >= lenght)
	return str;
	else
	return paddingLeft("0" +str,lenght);
}
// little-endian format
function littleendian(inputpayload) {
  var data = inputpayload.match(/../g);
  var buf = new ArrayBuffer(4);
  // Create a data view of it
  var view = new DataView(buf);
  // set bytes
  data.forEach(function (b, i) {
  view.setUint8(i, parseInt(b, 16));
  });
  // get an int32 with little endian
  var num = view.getInt32(0, 1);

  return num;
}
// little-endian format(hex to string)
function littleendianhex(inputpayload) {
  var inputlengh = inputpayload.length;
  var outputstr ='';
  for(let y=inputlengh;y>=1;y-=2){
    outputstr = outputstr+inputpayload[y-2]+inputpayload[y-1];
  }
  return outputstr;
}
// tabs sensor- Sound Level Sensor
function decodeUplink(input) {
  var fPort = input.fPort;
  var payloadlens = input.bytes.length;
  if(fPort==222 && payloadlens==17){//Frame Count 0 Content
    var intput_list = input.bytes;
    var intput_liststr='';
    for(let i=0;i<17;i++){
      intput_liststr = intput_liststr+paddingLeft(intput_list[i].toString(16),2);
    }
    var bootloader_hex = intput_liststr.toString("hex").substring(2, 10);
    var hwid_hex = intput_liststr.toString("hex").substring(10, 18);
    var fwcrc_hex = intput_liststr.toString("hex").substring(18, 26);
    bootloader = littleendianhex(bootloader_hex);
    HW_ID = littleendianhex(hwid_hex);
    FW_CRC = littleendianhex(fwcrc_hex);

    return {
      data: {
      fPort,
      bootloader,
      HW_ID,
      FW_CRC,
      },
    };
  }
  else if(fPort==204 && payloadlens==8){ //Response Content (Only for unconfirmed downlink)
    var intput_list = input.bytes;
    var intput_liststr='';
    for(let i=0;i<payloadlens;i++){
      intput_liststr = intput_liststr+paddingLeft(intput_list[i].toString(16),2);
    }

    var soud_keepalive_hex = intput_liststr.toString("hex").substring(2, 6);
    var soud_detect_hex = intput_liststr.toString("hex").substring(8, 12);
    var soud_rhdel_hex = intput_list[7].toString(16);

    var sound_keepalive = littleendian(soud_keepalive_hex); // (sec), Keep alive interval
    var sound_detect = littleendian(soud_detect_hex); // (oC) , Sensor detection interval
    var sound_dbtrig = parseInt(soud_rhdel_hex,16); // (oC), Sensor’s decibel threshold to trigger event

    return {
      data: {
        fPort,
        payloadlens,
        sound_keepalive,
        sound_detect,
        sound_dbtrig,
      },
    };
  }
  else if(fPort==105 && payloadlens==4){
    var intput_list = input.bytes;
    var battery_hex=intput_list[1].toString(16);
    var battery_binary = hex2bin(battery_hex); 
    var battery_binary2 = battery_binary.substring(4, 8);
    var battery_int = parseInt(battery_binary2,2)
    battery_volt = (25+battery_int)/10; // battery voltage
    
    var temp_hex=intput_list[2].toString(16);
    var temp_binary = hex2bin(temp_hex); 
    var temp_binary2 = temp_binary.substring(1, 8);
    var temp_int = parseInt(temp_binary2,2)
    temperature = temp_int-32; // Temperature on environment
        
    var sound_hex = intput_list[0].toString(16);
    var sound_binary = hex2bin(sound_hex);
    var sound_trigbin = sound_binary.substring(7,8); //[0]
    sound_trig = parseInt(sound_trigbin); //  0 -> keep alive, 1 -> trigger threshold event.
    
    var sound_dbhex = intput_list[3].toString(16);
    sound_db = parseInt(sound_dbhex,16); //sound Decibel value

    return {
      data: {
        fPort,
        battery_volt,
        temperature,
        sound_trig,
        sound_db
      },
    };
  }
  else{
    var fPort = input.fPort;
    var payloadlength = input.bytes.length;
    var message = 'Invalid fPort or payload length';
    return {
      data: {
        fPort,
        payloadlength,
        message,
      },
    };
  }
}

//#################### * Sound Level Sensor End !! *#################### //

//#################### * Water Leak Sensor  *#################### //

//hex to binary function
function hex2bin(hex){
  return (parseInt(hex, 16).toString(2)).padStart(8, '0');
}
// hex covert
function paddingLeft(str,lenght){
	if(str.length >= lenght)
	return str;
	else
	return paddingLeft("0" +str,lenght);
}
// little-endian format
function littleendian(inputpayload) {
  var data = inputpayload.match(/../g);
  var buf = new ArrayBuffer(4);
  // Create a data view of it
  var view = new DataView(buf);
  // set bytes
  data.forEach(function (b, i) {
  view.setUint8(i, parseInt(b, 16));
  });
  // get an int32 with little endian
  var num = view.getInt32(0, 1);

  return num;
}
// little-endian format(hex to string)
function littleendianhex(inputpayload) {
  var inputlengh = inputpayload.length;
  var outputstr ='';
  for(let y=inputlengh;y>=1;y-=2){
    outputstr = outputstr+inputpayload[y-2]+inputpayload[y-1];
  }
  return outputstr;
}
// tabs sensor- Water Leak Sensor
function decodeUplink(input) {
  var fPort = input.fPort;
  var payloadlens = input.bytes.length;
  
  if(fPort==222 && payloadlens==17){//Frame Count 0 Content
    var intput_list = input.bytes;
    var intput_liststr='';
    for(let i=0;i<17;i++){
      intput_liststr = intput_liststr+paddingLeft(intput_list[i].toString(16),2);
    }
    var bootloader_hex = intput_liststr.toString("hex").substring(2, 10);
    var hwid_hex = intput_liststr.toString("hex").substring(10, 18);
    var fwcrc_hex = intput_liststr.toString("hex").substring(18, 26);
    bootloader = littleendianhex(bootloader_hex);
    HW_ID = littleendianhex(hwid_hex);
    FW_CRC = littleendianhex(fwcrc_hex);

    return {
      data: {
      fPort,
      bootloader,
      HW_ID,
      FW_CRC,
      },
    };
  }
  else if(fPort==204 && payloadlens==10){ //Response Content (Only for unconfirmed downlink)
    var intput_list = input.bytes;
    var payloadlens = input.bytes.length;
    var intput_liststr='';
    for(let i=0;i<payloadlens;i++){
      intput_liststr = intput_liststr+paddingLeft(intput_list[i].toString(16),2);
    }

    var wl_keepalive_hex = intput_liststr.toString("hex").substring(2, 6);
    var wl_tempdel_hex = intput_list[4].toString(16);
    var wl_rhdel_hex = intput_list[6].toString(16);
    var wl_detect_hex = intput_liststr.toString("hex").substring(16, 20);

    var wl_keepalive = littleendian(wl_keepalive_hex); // (sec), Keep alive interval
    var wl_tempdelta = parseInt(wl_tempdel_hex,16); // (oC) , Temperature delta
    var wl_rhdelta = parseInt(wl_rhdel_hex,16); // (oC);
    var wl_detect = littleendian(wl_detect_hex); // (sec);

    return {
      data: {
        fPort,
        payloadlens,
        wl_keepalive,
        wl_tempdelta,
        wl_rhdelta,
        wl_detect,
      },
    };
  }
  else if(fPort==106 && payloadlens==5){
    var intput_list = input.bytes;
    var battery_hex=intput_list[1].toString(16);
    var battery_binary = hex2bin(battery_hex); 
    var battery_binary2 = battery_binary.substring(4, 8);
    var battery_int = parseInt(battery_binary2,2)
    battery_volt = (25+battery_int)/10; // battery voltage
    
    var temp_hex=intput_list[2].toString(16);
    var temp_binary = hex2bin(temp_hex); 
    var temp_binary2 = temp_binary.substring(1, 8);
    var temp_int = parseInt(temp_binary2,2);
    temperature_pcb = temp_int-32; // Temperature as measured by PCB board

    var water_hex = intput_list[0].toString(16);
    var water_binary = hex2bin(water_hex);
    var water_detebin = water_binary.substring(7,8); //[0]
    var water_interbin = water_binary.substring(3,4); //[4]
    var water_thchgbin = water_binary.substring(2,3); //[5]
    var water_rhchgbin = water_binary.substring(1,2); //[6]
    water_detect = parseInt(water_detebin); //  1 – Water leakage detected, 0 – Dry 
    water_interpt = parseInt(water_interbin); //  1 - Water leakage Interrupt
    water_thchg = parseInt(water_thchgbin); //  1 - Temperature status is changed ( 2℃ delta)
    water_rhchg = parseInt(water_rhchgbin); //  1 - RH status is changed  (5% RH delta)

    var humi_hex=intput_list[3].toString(16);
    var humi_binary = hex2bin(humi_hex); 
    var humi_binary2 = humi_binary.substring(1, 8);
    var humi_int = parseInt(humi_binary2,2);
    humidity = humi_int; // humidity on environment

    var tempb_hex=intput_list[4].toString(16);
    var tempb_binary = hex2bin(tempb_hex); 
    var tempb_binary2 = tempb_binary.substring(1, 8);
    var tempb_int = parseInt(tempb_binary2,2);
    temperature_env = tempb_int-32; // Temperature as measured by the sensor.

    return {
      data: {
        fPort,
        battery_volt,
        temperature_pcb,
        humidity,
        water_detect,
        water_interpt,
        water_thchg,
        water_rhchg,
        temperature_env
      },
    };
  }
  else{
    var fPort = input.fPort;
    var payloadlength = input.bytes.length;
    var message = 'Invalid fPort or payload length';
    return {
      data: {
        fPort,
        payloadlength,
        message,
      },
    };
  }
}

//#################### * Water Leak Sensor End !! *#################### //
//#################### * Object Locator Sensor  *#################### //

//hex to binary function
function hex2bin(hex){
  return (parseInt(hex, 16).toString(2)).padStart(8, '0');
}
// hex covert
function paddingLeft(str,lenght){
	if(str.length >= lenght)
	return str;
	else
	return paddingLeft("0" +str,lenght);
}
// little-endian format
function littleendian(inputpayload) {
  var data = inputpayload.match(/../g);
  var buf = new ArrayBuffer(4);
  // Create a data view of it
  var view = new DataView(buf);
  // set bytes
  data.forEach(function (b, i) {
  view.setUint8(i, parseInt(b, 16));
  });
  // get an int32 with little endian
  var num = view.getInt32(0, 1);

  return num;
}
// little-endian format(hex to string)
function littleendianhex(inputpayload) {
  var inputlengh = inputpayload.length;
  var outputstr ='';
  for(let y=inputlengh;y>=1;y-=2){
    outputstr = outputstr+inputpayload[y-2]+inputpayload[y-1];
  }
  return outputstr;
}
// GPS Lat calculate
function gnss_LatCal(firstbit,intput_lat){
  if(firstbit==0){
    var Lat_littleend_int = littleendian(intput_lat);
    const Lat_bit_01 = (Lat_littleend_int| (0xF0000000)) ^ (0xF0000000);
    const Lat_bit_02 = Lat_bit_01/1000000;
    return (Lat_bit_02.toString());
  }
  else{
    var Lat_littleend_int = littleendian(intput_lat);
    var Lat_bit_01 = Lat_littleend_int^0xFFFFFFFF;
    const Lat_bit_02 = (Lat_bit_01| (0xF0000000)) ^ (0xF0000000);
    const Lat_bit_03 = Lat_bit_02/1000000;
    return -(Lat_bit_03.toString());
  }
}
// GPS Lat calculate
function gnss_LongCal(firstbit,intput_long){
  if(firstbit==0){
    var Long_littleend_int = littleendian(intput_long);
    const Long_bit_01 = (Long_littleend_int| (0xE0000000)) ^ (0xE0000000);
    const Long_bit_02 = Long_bit_01/1000000;
    return (Long_bit_02.toString());
  }
  else{
    var Long_littleend_int = littleendian(intput_long);
    var Long_bit_01 = Long_littleend_int^0xFFFFFFFF;
    const Long_bit_02 = (Long_bit_01| (0xE0000000)) ^ (0xE0000000);
    const Long_bit_03 = Long_bit_02/1000000;
    return -(Long_bit_03.toString());
  }
}

// GNSS position estimate calculate
function gnss_PositCal(intput_posit){
  var Posit_int_01 = parseInt(intput_posit,16);
  const Posit_bit_01 = (Posit_int_01>>5);
  const Posit_bit_02 = Math.pow(2,(Posit_bit_01+2));
  return (Posit_bit_02.toString());
}
// tabs sensor- Object Locator Sensor
function decodeUplink(input) {
  var fPort = input.fPort;
  var payloadlens = input.bytes.length;
  if(fPort==222 && payloadlens==17){//Frame Count 0 Content
    var intput_list = input.bytes;
    var intput_liststr='';
    for(let i=0;i<17;i++){
      intput_liststr = intput_liststr+paddingLeft(intput_list[i].toString(16),2);
    }
    var bootloader_hex = intput_liststr.toString("hex").substring(2, 10);
    var hwid_hex = intput_liststr.toString("hex").substring(10, 18);
    var fwcrc_hex = intput_liststr.toString("hex").substring(18, 26);
    bootloader = littleendianhex(bootloader_hex);
    HW_ID = littleendianhex(hwid_hex);
    FW_CRC = littleendianhex(fwcrc_hex);

    return {
      data: {
      fPort,
      bootloader,
      HW_ID,
      FW_CRC,
      },
    };
  }
  else if(fPort==204 && payloadlens==9){ //Response Content
    var intput_list = input.bytes;
    var payloadlens = input.bytes.length;
    var intput_liststr='';
    for(let i=0;i<payloadlens;i++){
      intput_liststr = intput_liststr+paddingLeft(intput_list[i].toString(16),2);
    }

    var obj_move_hex = intput_liststr.toString("hex").substring(2, 6);
    var obj_keep_hex = intput_liststr.toString("hex").substring(8, 12);
    var obj_gsensor_hex = intput_liststr.toString("hex").substring(14, 18);

    var obj_move = littleendian(obj_move_hex); // (sec); Update event interval when the sensor is in moving mode.
    var obj_keepalive = littleendian(obj_keep_hex); // (sec); Keep alive interval when the sensor is in stationary mode.
    var obj_gsensor = littleendian(obj_gsensor_hex); //(sec); G-sensor timeout interval when the sensor is moving.

    return {
      data: {
        fPort,
        payloadlens,
        obj_move,
        obj_keepalive,
        obj_gsensor,
      },
    };
  }
  else if(fPort==136 && payloadlens==11){
    var intput_list = input.bytes;
    var battery_hex=intput_list[1].toString(16);
    var battery_binary = hex2bin(battery_hex); 
    var battery_binary2 = battery_binary.substring(4, 8);
    var battery_int = parseInt(battery_binary2,2)
    battery_volt = (25+battery_int)/10; // battery voltage
    
    var temp_hex=intput_list[2].toString(16);
    var temp_binary = hex2bin(temp_hex); 
    var temp_binary2 = temp_binary.substring(1, 8);
    var temp_int = parseInt(temp_binary2,2)
    temperature = temp_int-32; // Temperature as measured by PCB board

    var object_hex = intput_list[0].toString(16);
    var object_binary = hex2bin(object_hex);
    var obj_btnbin = object_binary.substring(7,8); //[0]
    var obj_movebin = object_binary.substring(6,7); //[1]
    var obj_gnsfixbin = object_binary.substring(4,5); //[3]
    var obj_gnserrbin = object_binary.substring(3,4); //[4]

    obj_button = parseInt(obj_btnbin); //  1 - button trigger event, 0 - no button trigger event
    obj_move = parseInt(obj_movebin); //  1 - moving mode, 0 - stationary mode
    obj_gnsfix = parseInt(obj_gnsfixbin); //  1 - no GNSS fix, 0 - GNSS fixed
    obj_gnserr = parseInt(obj_gnserrbin); //  1 - GNSS error, 0 - GNSS OK

    var intput_liststr='';
    for(let i=0;i<11;i++){
      intput_liststr = intput_liststr+paddingLeft(intput_list[i].toString(16),2);
    }
    // * Latitude as last reported by GNSS receiver - calculate * //
    var gnssLat_hex = intput_liststr.toString("hex").substring(6, 14);
    var gnssLatbit_hex = intput_liststr.toString("hex").substring(12, 14);
    var gnssLatbit_neg = (hex2bin(gnssLatbit_hex)).toString().substring(4,5);
    var gnssLat_final = gnss_LatCal(gnssLatbit_neg,gnssLat_hex);  // Latitude as last reported by GNSS receiver
    // * Longitude as last reported by GNSS receiver - calculate * //
    var gnssLong_hex = intput_liststr.toString("hex").substring(14, 22);
    var gnssLongbit_hex = intput_liststr.toString("hex").substring(20, 22);
    var gnssLongbit_neg = (hex2bin(gnssLongbit_hex)).toString().substring(3,4);
    var gnssLong_final = gnss_LongCal(gnssLongbit_neg,gnssLong_hex);  //Longitude as last reported by GNSS receiver
    // * position accuracy estimate - calculate * //
    var gnssPosit_hex = intput_liststr.toString("hex").substring(20, 22);
    var gnssPosit_final = gnss_PositCal(gnssPosit_hex);     //Position accuracy estimate by GNSS receiver
    
    return {
      data: {
        fPort,
        battery_volt,
        temperature,
        obj_button,
        obj_move,
        obj_gnsfix,
        obj_gnserr,
        gnssLat_final,
        gnssLong_final,
        gnssPosit_final
      },
    };
  }
  else{
    var fPort = input.fPort;
    var payloadlength = input.bytes.length;
    var message = 'Invalid fPort or payload length';
    return {
      data: {
        fPort,
        payloadlength,
        message,
      },
    };
  }
}


//#################### * Object Locator Sensor End !! *#################### //

//#################### * Industrial Tracker Sensor  *#################### //

//hex to binary function
function hex2bin(hex){
  return (parseInt(hex, 16).toString(2)).padStart(8, '0');
}
// hex covert
function paddingLeft(str,lenght){
	if(str.length >= lenght)
	return str;
	else
	return paddingLeft("0" +str,lenght);
}
// little-endian format
function littleendian(inputpayload) {
  var data = inputpayload.match(/../g);
  var buf = new ArrayBuffer(4);
  // Create a data view of it
  var view = new DataView(buf);
  // set bytes
  data.forEach(function (b, i) {
  view.setUint8(i, parseInt(b, 16));
  });
  // get an int32 with little endian
  var num = view.getInt32(0, 1);

  return num;
}
// little-endian format(hex to string)
function littleendianhex(inputpayload) {
  var inputlengh = inputpayload.length;
  var outputstr ='';
  for(let y=inputlengh;y>=1;y-=2){
    outputstr = outputstr+inputpayload[y-2]+inputpayload[y-1];
  }
  return outputstr;
}
// GPS Lat calculate
function gnss_LatCal(firstbit,intput_lat){
  if(firstbit==0){
    var Lat_littleend_int = littleendian(intput_lat);
    const Lat_bit_01 = (Lat_littleend_int| (0xF0000000)) ^ (0xF0000000);
    const Lat_bit_02 = Lat_bit_01/1000000;
    return (Lat_bit_02.toString());
  }
  else{
    var Lat_littleend_int = littleendian(intput_lat);
    var Lat_bit_01 = Lat_littleend_int^0xFFFFFFFF;
    const Lat_bit_02 = (Lat_bit_01| (0xF0000000)) ^ (0xF0000000);
    const Lat_bit_03 = Lat_bit_02/1000000;
    return -(Lat_bit_03.toString());
  }
}
// GPS Lat calculate
function gnss_LongCal(firstbit,intput_long){
  if(firstbit==0){
    var Long_littleend_int = littleendian(intput_long);
    const Long_bit_01 = (Long_littleend_int| (0xE0000000)) ^ (0xE0000000);
    const Long_bit_02 = Long_bit_01/1000000;
    return (Long_bit_02.toString());
  }
  else{
    var Long_littleend_int = littleendian(intput_long);
    var Long_bit_01 = Long_littleend_int^0xFFFFFFFF;
    const Long_bit_02 = (Long_bit_01| (0xE0000000)) ^ (0xE0000000);
    const Long_bit_03 = Long_bit_02/1000000;
    return -(Long_bit_03.toString());
  }
}

// GNSS position estimate calculate
function gnss_PositCal(intput_posit){
  var Posit_int_01 = parseInt(intput_posit,16);
  const Posit_bit_01 = (Posit_int_01>>5);
  const Posit_bit_02 = Math.pow(2,(Posit_bit_01+2));
  return (Posit_bit_02.toString());
}

// tabs sensor- Industrial Tracker Sensor
function decodeUplink(input) {
  var fPort = input.fPort;
  var payloadlens = input.bytes.length;
  if(fPort==222 && payloadlens==17){
    var intput_list = input.bytes;
    var intput_liststr='';
    for(let i=0;i<17;i++){
      intput_liststr = intput_liststr+paddingLeft(intput_list[i].toString(16),2);
    }
    var bootloader_hex = intput_liststr.toString("hex").substring(2, 10);
    var hwid_hex = intput_liststr.toString("hex").substring(10, 18);
    var fwcrc_hex = intput_liststr.toString("hex").substring(18, 26);
    bootloader = littleendianhex(bootloader_hex);
    HW_ID = littleendianhex(hwid_hex);
    FW_CRC = littleendianhex(fwcrc_hex);

    return {
      data: {
      fPort,
      bootloader,
      HW_ID,
      FW_CRC,
      },
    };
  }
  else if(fPort==204 && payloadlens==9){
    var intput_list = input.bytes;
    var payloadlens = input.bytes.length;
    var intput_liststr='';
    for(let i=0;i<payloadlens;i++){
      intput_liststr = intput_liststr+paddingLeft(intput_list[i].toString(16),2);
    }

    var intk_move_hex = intput_liststr.toString("hex").substring(2, 6);
    var intk_keep_hex = intput_liststr.toString("hex").substring(8, 12);
    var intk_gsensor_hex = intput_liststr.toString("hex").substring(14, 18);

    var intk_move = littleendian(intk_move_hex); // (sec); Update event interval when the sensor is in moving mode.
    var intk_keepalive = littleendian(intk_keep_hex); // (sec); Keep alive interval when the sensor is in stationary mode.
    var intk_gsensor = littleendian(intk_gsensor_hex); //(sec); G-sensor timeout interval when the sensor is moving.

    return {
      data: {
        fPort,
        payloadlens,
        intk_move,
        intk_keepalive,
        intk_gsensor
      },
    };
  }
  else if(fPort==136 && payloadlens==11){
    var intput_list = input.bytes;
    var battery_hex=intput_list[1].toString(16);
    var battery_binary = hex2bin(battery_hex); 
    var battery_binary2 = battery_binary.substring(4, 8);
    var battery_int = parseInt(battery_binary2,2)
    battery_volt = (25+battery_int)/10; // battery voltage
    
    var temp_hex=intput_list[2].toString(16);
    var temp_binary = hex2bin(temp_hex); 
    var temp_binary2 = temp_binary.substring(1, 8);
    var temp_int = parseInt(temp_binary2,2)
    temperature = temp_int-32; // Temperature as measured by PCB board

    var object_hex = intput_list[0].toString(16);
    var object_binary = hex2bin(object_hex);
    var obj_movebin = object_binary.substring(7,8); //[0]
    var obj_gnsfixbin = object_binary.substring(4,5); //[3]
    var obj_gnserrbin = object_binary.substring(3,4); //[4]

    intk_move = parseInt(obj_movebin); //  1 - moving mode, 0 - stationary mode
    intk_gnsfix = parseInt(obj_gnsfixbin); //  1 - no GNSS fix, 0 - GNSS fixed
    intk_gnserr = parseInt(obj_gnserrbin); //  1 - GNSS error, 0 - GNSS OK

    var intput_liststr='';
    for(let i=0;i<11;i++){
      intput_liststr = intput_liststr+paddingLeft(intput_list[i].toString(16),2);
    }
    // * Latitude as last reported by GNSS receiver - calculate * //
    var gnssLat_hex = intput_liststr.toString("hex").substring(6, 14);
    var gnssLatbit_hex = intput_liststr.toString("hex").substring(12, 14);
    var gnssLatbit_neg = (hex2bin(gnssLatbit_hex)).toString().substring(4,5);
    var gnssLat_final = gnss_LatCal(gnssLatbit_neg,gnssLat_hex);  // Latitude as last reported by GNSS receiver
    // * Longitude as last reported by GNSS receiver - calculate * //
    var gnssLong_hex = intput_liststr.toString("hex").substring(14, 22);
    var gnssLongbit_hex = intput_liststr.toString("hex").substring(20, 22);
    var gnssLongbit_neg = (hex2bin(gnssLongbit_hex)).toString().substring(3,4);
    var gnssLong_final = gnss_LongCal(gnssLongbit_neg,gnssLong_hex);  //Longitude as last reported by GNSS receiver
    // * position accuracy estimate - calculate * //
    var gnssPosit_hex = intput_liststr.toString("hex").substring(20, 22);
    var gnssPosit_final = gnss_PositCal(gnssPosit_hex);     //Position accuracy estimate by GNSS receiver
    
    return {
      data: {
        fPort,
        battery_volt,
        temperature,
        intk_move,
        intk_gnsfix,
        intk_gnserr,
        gnssLat_final,
        gnssLong_final,
        gnssPosit_final
      },
    };
  }
  else{
    var fPort = input.fPort;
    var payloadlength = input.bytes.length;
    var message = 'Invalid fPort or payload length';
    return {
      data: {
        fPort,
        payloadlength,
        message,
      },
    };
  }
}

//#################### * Industrial Tracker Sensor End !! *#################### //

//#################### * Temperature Probe Sensor  *#################### //
//hex to binary function
function hex2bin(hex) {
    return (parseInt(hex, 16).toString(2)).padStart(8, '0');
}
// hex covert
function paddingLeft(str, lenght) {
    if (str.length >= lenght)
        return str;
    else
        return paddingLeft("0" + str, lenght);
}
// little-endian format
function littleendian(inputpayload) {
    var data = inputpayload.match(/../g);
    var buf = new ArrayBuffer(4);
    // Create a data view of it
    var view = new DataView(buf);
    // set bytes
    data.forEach(function (b, i) {
        view.setUint8(i, parseInt(b, 16));
    });
    // get an int32 with little endian
    var num = view.getInt32(0, 1);

    return num;
}
// little-endian format(hex to string)
function littleendianhex(inputpayload) {
    var inputlengh = inputpayload.length;
    var outputstr = '';
    for (let y = inputlengh; y >= 1; y -= 2) {
        outputstr = outputstr + inputpayload[y - 2] + inputpayload[y - 1];
    }
    return outputstr;
}
// debug console log
function debug_console_log(log) {
    // console.log(log);
    return;
}
// Temperature Probe Sensor
function decodeUplink(input) {
    var fPort = input.fPort;
    var payloadlens = input.bytes.length;

    debug_console_log('fPort: ' + fPort);
    debug_console_log('payloadlens: ' + payloadlens);

    if (fPort == 222 && payloadlens == 17) {
        // Frame Count 0 Content
        var intput_list = input.bytes;
        var intput_liststr = '';
        for (let i = 0; i < 17; i++) {
            intput_liststr = intput_liststr + paddingLeft(intput_list[i].toString(16), 2);
        }
        var bootloader_hex = intput_liststr.toString("hex").substring(2, 10);
        var hwid_hex = intput_liststr.toString("hex").substring(10, 18);
        var fwcrc_hex = intput_liststr.toString("hex").substring(18, 26);

        var bootloader = littleendianhex(bootloader_hex);
        var HW_ID = littleendianhex(hwid_hex);
        var FW_CRC = littleendianhex(fwcrc_hex);

        var ret_data = {
            data: {
                fPort,
                bootloader,
                HW_ID,
                FW_CRC,
            },
        };
        debug_console_log('ret_data: ' + JSON.stringify(ret_data));

        return ret_data;
    }
    else if (fPort == 204 && payloadlens == 12) {
        // Response Content (Only for unconfirmed downlink)
        var intput_list = input.bytes;
        var intput_liststr = '';
        for (let i = 0; i < payloadlens; i++) {
            intput_liststr = intput_liststr + paddingLeft(intput_list[i].toString(16), 2);
        }

        var temp_probe_keepalive_hex = intput_liststr.toString("hex").substring(2, 6);
        var temp_probe_detect_time_int_hex = intput_liststr.toString("hex").substring(8, 12);
        var temp_probe_temp_delta_hex = intput_list[7].toString(16);
        var temp_probe_max_temp_hex = intput_list[9].toString(16);
        var temp_probe_min_temp_hex = intput_list[11].toString(16);

        var temp_probe_keepalive = littleendian(temp_probe_keepalive_hex); // (sec), Keep alive interval
        var temp_probe_detect_time_int = littleendian(temp_probe_detect_time_int_hex); // (sec) , Detection time interval
        var temp_probe_temp_delta = parseInt(temp_probe_temp_delta_hex, 16); // (oC) , Temperature delta
        var temp_probe_max_temp = parseInt(temp_probe_max_temp_hex, 16); // (oC) , Maximum temperature limit
        temp_probe_max_temp = temp_probe_max_temp - 55;
        var temp_probe_min_temp = parseInt(temp_probe_min_temp_hex, 16); // (oC) , Minimum temperature limit
        temp_probe_min_temp = temp_probe_min_temp - 55;

        var ret_data = {
            data: {
                fPort,
                payloadlens,
                temp_probe_keepalive,
                temp_probe_detect_time_int,
                temp_probe_temp_delta,
                temp_probe_max_temp,
                temp_probe_min_temp,
            },
        };
        debug_console_log('ret_data: ' + JSON.stringify(ret_data));

        return ret_data;
    }
    else if (fPort == 112 && payloadlens == 5) {
        var intput_list = input.bytes;

        var battery_v = intput_list[1];
        battery_v = battery_v & 0x0f;
        var battery_volt = (25 + battery_v) / 10; // battery voltage

        var temp_pcb_t = intput_list[2];
        temp_pcb_t = temp_pcb_t & 0x7f;
        var temp_pcb = temp_pcb_t - 32; // board temperature

        var temp_probe_t = (intput_list[4] << 8) | intput_list[3];
        var temp_probe = (2000 - temp_probe_t) * 0.0625; // temp-probe temperature

        var ret_data = {
            data: {
                fPort,
                battery_volt,
                temp_pcb,
                temp_probe,
            },
        };
        debug_console_log('ret_data: ' + JSON.stringify(ret_data));

        return ret_data;
    }
    else {
        var fPort = input.fPort;
        var payloadlength = input.bytes.length;
        var message = 'Invalid fPort or payload length';

        var ret_data = {
            data: {
                fPort,
                payloadlength,
                message,
            },
        };
        debug_console_log('ret_data: ' + JSON.stringify(ret_data));

        return ret_data;
    }
}
//#################### * Temperature Probe Sensor End !! *#################### //
